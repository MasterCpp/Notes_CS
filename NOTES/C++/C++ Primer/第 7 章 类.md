# 第 7 章 类

## 7.1 定义抽象数据类型

Sales_data类

```c++
struct Sales_data
{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```

以上不是一个抽象数据类型，它允许类的用户直接访问它的成员函数，并且要求用户来编写操作。

### 7.1.1设计Sales_data类

1. Sales_data接口应该包含以下操作：

 （1）一个isbn成员函数，用于返回对象的ISBN编号 

 （2）一个combine成员函数，用于将一个Sales_data对象加到另一个对象上

 （3）一个名为add的函数，执行两个Sales_data对象的加法

 （4）一个read函数，将数据从istream读入到Sales_data对象中

 （5）一个print函数，将Sales_data对象的值输出到ostream

2.使用改进的Sales_data类

```c++
Sales_data total; //保存当前求和结果的变量
if(read(cin, total)) //读入第一笔交易
{
    Sales_data trans;//保存下一条交易数据的变量
    while(read(cin, trans))//读入剩余的交易
    {
        if(total.isbn() == trans.isbn())//检查isbn
            total.combine(trans);//更新变量total当前值
        else{
            print(cout, total) << endl;//输出结果
            total = trans;//处理下一本书
			}
	}
    print(cout, total) << endl;
}
else {
	cerr << "NO data!" <<endl;
}
```

以上是通过函数来编写，以下是原程序

```C++
#include<iostream>
#include"Sales_item.h"
int main()
{
    Sales_item total;//保存下一条交易记录的变量
    //读入第一条数据，并确保有数据可以处理
    if(std::cin >> total)
    {
        Sales_item trans;//保存和的变量
        //读入并处理剩余交易记录
        while(std::cin >> trans)
        {
            //如果处理相同的书
    		if(total.isbn() == trans.isbn())
                total += trans;
            else
            {
             	//打印前一本书的结果
                std::cout << total << std::endl;
                total = trans;//total表示夏一本书的销售额
            }
        
        }
        std::cout << total << std::endl;//打印最后一本书的结果
	}
    else
    {
        //没有输入，警告读者
        std::cerr << "No data！" << std::endl;
        return -1;
    }
    return 0;
}
```

### 7.1.2  定义改进的Sales_data类

```c++
struct Sales_data
{
    std::string isbn() const { return bookNo;}
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
//Sales_data的非接口成员函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

#### (1)  定义成员函数

成员函数可以在类内，也可以在类外

首先是isbn函数，参数列表为空，返回一个Sales_data对象的bookNo数据成员。、

Q：isbn函数如果获得bookNo成员所依赖的对象呢？

#### (2)  引入this

total.isbn()

​     当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员（例bookNo），则它隐式地指向调用该函数的对象的成员。就如上例，当isbn返回bookNo时，实际上是隐式地返回total.bookNo

​        成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数 时，用请求该函数的对象地址初始化this，例如，如果调用 

​	total.isbn()

则编译器负责把total的地址传递给isbn的隐式形参this，可以认为等价于下列代码

Sales_data::isbn(&total)  //调用Sales_data的isbn成员时传入了total的地址

​       在成员函数内部，可以直接使用调用该函数的对象的成员，无需通过成员访问运算符来做到，因为this所指的就是这个对象。任何对类成员的直接访问都被看成this的隐式引用。即，当isbn使用bookNo时，它隐式地使用this指向的成员

尽量将isbn定义为： 

```
std::string isbn() const {return this->bookNo;}
```

this的目的总是指向“这个”对象，this是一个常量指针，不能改变this中保存的地址

#### (3)  引入const成员函数

```C++
std::string isbn() const { return bookNo;}
```

isbn()函数另一个关键之处就是参数列表后的 **const** 关键字，它的作用是修改隐式this指针的类型

默认情况下，this的类型是指向类类型非常量版本的常量指针，例如上例，this的类型是**Sales_data *const**。尽管this是隐式的，但this仍然需要遵循初始化规则，默认情况下，我们不能把this绑定到常量对象上。即不能在一个常量对象上调用普通的成员函数。

若isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明称**const Sales_data *const**。在isbn函数体内不会改变this所指的对象，所以把this设置成指向常量的指针有助于提高函数的灵活性。

但this是隐式的并且不会出现在参数列表中，在哪将this声明成指向常量是指针就很关键，C++允许将const关键字放在成员函数的参数列表之后

**！！常量对象，以及常量对象的引用或指针都只能调用常量成员函数**

#### (4)  类作用域和成员函数

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序。

#### (5)  在类的外部定义成员函数

在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。成员被声明为常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时类外部定义的成员的名字必须包含他所属的类名。

```C++
double Sales_data::avg_price() const
{
    if(units_sold)
        return revenue/units_sold;
    else
        return 0;
}
```

上述代码：

函数名Sales_data::avg_price使用作用于操作符来说明以下事实，定义了一个名为avg_price 的函数，并且该函数被声明在类Sales_data的作用域内。

(6)  定义一个返回this对象的函数

函数combine的设计类似于复合赋值操作符+=，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数。

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold;//把rhs的成员加到this对象的成员上
    revenue += rhs.revenue;
    return *this;//返回调用该函数的对象
}
```

源程序调用 

```C++
total.combine(trans);
```

total的地址被绑定到隐式this参数上，而rhs绑定的到了trans上，所以combine执行

```C++
units_sold += rhs.units_sold;
```

效果等同于求total.units_sold和trans.unit_sold的和，然后把结果保存到total.units_sold中

返回类型和返回语句值得关注。一般来说当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回，因此为了保持与之一致，combine函数必须返回引用类型。

如前所述，我们无序使用隐式的this指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问

所以return语句解引用this指针已获得执行该函数的对象，换句话说，上面的return *this，其实是返回total的引用。

### 7.1.3  定义类相关的非成员函数

通常需要定义一些辅助函数，比如add、read和print等，尽管这些函数定义的操作从概念上来说属，于类的接口的组成部分，但它们实际上并不属于类本身。定义非成员函数的方式与定义其他函数一样，通常把函数的声明与定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明在同一个头文件中。

**！！一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中。**

(1)  定义read和print函数

```C++
istream &read(istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNp >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}
ostream &print(ostream &os, Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_pricez();
    return os;
}
```

比较重要的几点：

* read和print分别接受一个各自IO类型的引用作为其参数，这是因为**IO类属于不能被拷贝的类型**，所以只能通过引用的方式来传递，而且因为读取和写入的操作会改变流的内容，所以两个函数接受的是普通引用，而非对常量的引用。

* print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。

(2)  定义add函数

```C++
Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
	Sales_data sum = lhs;
    sum.combine(rhs);
    return sum;
}
```

### 7.1.4  构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

a.构造函数没有返回类型

b.不同的构造函数之间必须在参数数量或参数类型上有所区别

#### (1)  合成的默认构造函数

Sales_data类中：

```c++
Sales_data total;
Sales_data trans;
```

Sales_data类中并没有定义任何构造函数，那么这俩对象是如何初始化的呢？

没有为这些对象提供初始值，因此我们知道这俩对象执行了默认初始化。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫**默认构造函数**。默认构造函数无序任何实参。

可以看出，默认构造函数在很多方面有其特殊性，其中之一是，如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。

编译器创建的构造函数又被称作**合成的默认构造函数**。按照如下顺序初始化类的数据成员：

* 如果存在类内的初始值，用它来初始化成员

* 否则，默认初始化该成员

#### (2)  某些类不能依赖于合成的默认构造函数

合成的构造函数只适用于非常简单的类，比如上述Sales_data类。对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：

* 编译器只有在发现类不包括任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了某个构造函数，除非我们再定义一个默认的构造函数，否则类内将没有默认构造函数。依据就是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。

* 对于某些类来说，合成的默认构造函数可能执行错误的操作。比如，如果定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则它们的值将是未定义的，这个准则同样适用于默认初始化的内置类型成员。【如果包含内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适用于使用合成的默认构造函数】

* 有的时候编译器不能为某些类合成默认的构造函数。例如，一个类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器无法初始化该成员。

#### (3)  定义Sales_data的构造函数

```c++
struct Sales_data
{
    //新增的构造函数
    Sales_data() = default;
    Sales_data(const std::string &s): bookNo(s)
    {
        
    }
    Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n)
    {
        
    }
    Sales_data(std::istream &);
    //之前已有的其他成员
    std::string isbn() const { return bookNo;}
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```

上述代码有新增部分

* 首先是  **=default** 的含义

```C++
Sales_data () = default;
```

必须要明确的一点是：因为该构造函数不接受任何实参，所以它是一个默认构造函数。定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。

在C++11新标准中，如果我们需要默认的行为，那么我们可以在参数列表后面写上 =default 来要求编译器生成构造函数

* 其次是构造函数初始值列表部分

  ```c++
  Sales_data(const std::string &s): bookNo(s) {}     
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  ```

新的部分即冒号以及冒号和花括号之间的代码，花括号定义了(空的)函数体。新出现的部分称为**构造函数初始值列表**，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的成员初始值。

只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显式初始化，它将以与合成默认构造函数相关的方式隐式初始化。等价于以下：

```c++
Sales_data(const std::string &s): 
			bookNo(s), units_sold(0), revenue(0) {}
```

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在，我们就能确保为成员赋予了一个正确的值。

构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。

#### (4)  在类的外部定义构造函数

以istream为参数的构造函数需要执行一些实际的操作，在它的函数体内，调用了read函数以给数据成员赋初值

```c++
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this);//read函数的作用是从is中读取一条交易然后存入this对象中
}
```

构造函数没有返回类型，所以上述定义从我们指定的函数名字开始。和其他成员函数一样，当我们在类外定义构造函数时，必须指明该构造函数是哪个类的成员。所以Sales_data::Sales_data的含义是我们定义Sales_data类的成员，成员的名字是Sales_data。又因为该成员的名字与类名相同，所以它是一个构造函数。

### 7.1.5  拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象发生时发生的行为。

(1)  某些类不能依赖于合成的版本

尽管编译器能替我们合成拷贝、赋值和销毁的操作，必须清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。

## 7.2  访问控制与封装

类还没有封装，也就是说用户可以直达Sales_data对象的内部并且控制它的具体实现细节。在c++中我们可以使用**访问说明符**加强类的封装

* 定义在**public**说明符之后的成员在整个程序内可被访问，public成员定义类的接口；
* 定义在**private**说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分隐藏类的部分细节

Sales_data类的新形式如下

```c++
class Sales_data
{
public:
    Sales_data() = default;
    Sales_data(const std::string &S, unsigned n, double p):
    bookNo(s), unit_sold(n), revenue(p*n) {}
    Sales_data(const std::string &s): bookNo(s) {}
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);
private:
    double avg_price() const
    { return units_sold ? revenue/units_sold : }
    std::string bookNo;
    unsigned units_sold;
    double revenue = 0.0;
```

作为接口的一部分，构造函数和部分成员函数（isbn和combine）紧跟在public后面；而数据成员和作为实现部分的函数则跟在private后面。

一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定

### 7.2.1  友元

类允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的**友元（friend）**，如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。

```c++
class Sales_data
{
//为Sales_data的非成员函数所做的友元声明
friend Sales_data add(const Sales_data&， const Sales_data&)；
friend std::istream &read(std::istream&, Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);
public:
    Sales_data() = default;
    Sales_data(const std::string &S, unsigned n, double p):
    bookNo(s), unit_sold(n), revenue(p*n) {}
    Sales_data(const std::string &s): bookNo(s) {}
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);
private:
    double avg_price() const
    { return units_sold ? revenue/units_sold : }
    std::string bookNo;
    unsigned units_sold;
    double revenue = 0.0;
};
```

友元部分只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也也不受它所在区域访问控制级别的约束

最好在类定义的开始或结束前的位置集中声明友元

#### (1)  友元的声明

类的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。

## 7.3  类的其它特性

### 7.3.1  类成员再探

首先定义一对相互关联的类，分别是Screen和Window_mgr

#### (1)  定义一个类型成员

Screen表示显示器中的一个窗口。每个Screen包含一个保存Screen内容的string成员和三个string::size_type类型的成员，它们分别表示光标的位置以及屏幕的高和宽。除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种：

```c++
class Screen
{
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0,width = 0;
    std::string contents;
};
```

用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，因此类型成员通常出现在类开始的地方。

#### (2)  Screen类的成员函数

要想要类更实用，还需要添加一个构造函数令用户能够定义屏幕的尺寸和内容，以及其他两个成员，分别负责移动光标和读取给定位置的字符：

```c++
class Screen
{
public:
	typedef std::string::size_type pos;
    Screen() = default;
    Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht * wd, 	 c) {}
    char get() const
    	{ return contents[cursor]; }
    inline char get(pos r, pos c);
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```

#### (3)  令成员作为内联函数

#### (4)  重载成员函数

与非成员函数一样，成员函数也可以重载

#### (5)  可变数据成员

有时我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入**mutable**关键字做到这一点。一个可变数据成员永远不会是const，即使它是const对象的成员。

#### (6)  类数据成员的初始值

定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组Screen。这个类包含一个Screen类的vector，每个元素表示一个特定的Screen。默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen

```c++
class Window_mgr{
    private:
    //默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen
    std::vector<Screen> screens(Screen(24, 80, ' '));
}
```

当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在上例中，我们使用一个单独的元素值对vector成员执行了列表初始化，这个Screen的值被传递给vector<Screen>的构造函数，从而创建了一个单元素的vector对象。具体来说，Screen的构造函数接受两个尺寸函数和一个字符值，创建了一个给定大小的空白屏幕对象。

类内初始值必须使用=的初始化形式(初始化Screen的数据成员所用)或者花括号括起来的直接初始化形式(初始化screens所用)

### 7.3.2  返回*this的成员函数

继续添加一些函数，它们负责设置光标所在位置的字符或者其他任一给定位置的字符

```c++
class Screen
{
public:
    //新的函数
    Screen &set(char);
    Screen &set(pos, pos, char);
    //初始函数
	typedef std::string::size_type pos;
    Screen() = default;
    Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht * wd, 	 c) {}
    char get() const
    	{ return contents[cursor]; }
    inline char get(pos r, pos c);
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
inline Screen &Screen::set(char c)
{
    contents[cursor] = c;	//设置当前光标位置的新值
    return *this;			//将this对象作为左值返回
}
inline Screen &Screen::set(pos r, pos col, char ch)
{
    contents[r*width + col] = ch;	//设置给定位置的新值
    return *this；					//将this对象作为左值返回
}
```

set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本

#### (1)  从const成员函数返回*this

添加一个display的操作，负责打印Screen的内容。显示一个Screen并不需要改变它的内容，因此我们令display为一个const成员，此时，this将是一个指向const的指针而*this是const对象，由此推断，display的返回类型应该是 const Sales_data&.然而，真的令display返回一个const的引用，则我们将不能把display嵌入到一组动作的序列中去

```c++
Screen myScreen;
//如果display返回常量引用，则调用set将引发错误
myScreen.display(cout).set('*');
```

即使myScreen是个非常量对象，对set的调用也无法通过编译。问题在于display的const版本返回的是常量引用，而我们显然无权set一个常量对象

**！！一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用**

#### (2) 基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载，其原因与我们之前根据指针参数是否指向const而重载函数的原因差不多。具体来说，因为非常量版本的函数对于常量对象是不可引用的，所以我们只能在一个常量对象上调用const成员函数。

```c++
class Screen{
public:
    //根据对象是否是const重载了display函数
    Screen &display(std::ostream &os)
    {
        do_display(os);
        return *this;
    }
    const Screen &display(std::ostream &os) const
    {
        do_display(os);
        return *this;
    }
private:
    //该函数负责显示Screen的内容
    void do_display(std::ostream &os) const
    {
        os << contents;
    }
    //其他成员与之前版本一致
}
```

当一个成员调用另外一个成员时，this指针在其中隐式地传递。所以display调用do_display时，它的this指针隐式地传递给do_display。而当display的非常量版本调用do_display时，它的this指针将隐式地从指向非常量的指针转换成指向常量的指针。

而当do_display完成后，display函数各自返回解引用this所得的对象。

### 7.3.3  类类型

每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是不同的两个类型。

#### (1)  类的声明

类似于函数的声明与定义，我们也能仅仅声明类而暂时不定义它。

class Screen;	//Screen类的声明

上例有时被称作前向声明，它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，声明之后定义之前是一个不完全类型，其只能在非常有限的情境下使用：

* 可以定义指向这种类型的指针或引用
* 也可以声明以不完全类型作为参数或者返回类型的函数

### 7.3.4  友元再探

#### (1)  类之间的友元关系

Window_mgr类的某些成员可能需要访问它管理的Screen类的内部数据。例如需要为Window_mgr添加一个名为clear的成员，它负责把一个指定的Screen的内容都设为空白。所以，clear需要访问Screen的私有成员

```C++
class Screen{
    friend class Winow_mgr;
};    
```

如果一个类指定了友元类，那么友元类的成员函数可以访问此类所有成员。Window_mgr被指定为Screen的友元，因此我们可以将clear成员写为

```c++
class Window_mgr{
public:
    //窗口中每个屏幕的编号
    using ScreenIndex = std::vector<Screen>::size_type;
    //按照编号将指定的Screen重置为空白
    void clear(ScreenIndex);
private:
    std::vector<Screen> screens{Screen(24, 80, " ")};
};
void Window_mgr::clear(SCreenIndex i)
{
    //s是一个Screen的引用，指向想清空的那个屏幕
	Screen &s = screens[i];
    //将选定的Screen重置为空白
    s.contents = string(s.height * s.width, ' ');
};
```

上述代码中，首先把s定义成screens vector中第i个位置上的Screen引用，随后利用Screen的height和width成员计算出一个新的string对象，并令其有若干个空白字符，最后把这个含有很多空白的字符串赋给contents成员。

**！！ 友元关系不存在传递性，如果Window_mgr有它自己的友元，则这些友元不能理所应当的具有访问Screen的特权。**

#### (2)  令成员函数作为友元

Screen还可以只为clear提供访问权限。把一个成员函数声明成友元时，必须明确指出该成员函数属于哪个类

```c++
class Screen{
	//Window_mgr::clear必须在Screen类之前被声明
    friend void Window_mgr::clear(ScreenIndex);
    //Screen类的剩余部分
};
```

令某个成员函数作为友元，必须按照以下顺序：

* 首先定义Window_mgr类，其中声明clear函数，但不能定义。在clear使用Screen的成员之前必须先声明Screen
* 接下来定义Screen，包括对于clear的友元声明
* 最后定义clear，此时它才可以使用Screen的成员

#### (3)  函数重载和友元

一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明

#### (4)  友元声明和作用域

类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域是可见的。然而，友元本身不一定真的声明在当前作用域中。

甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。也就是说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。

## 7.4  类的作用域

每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。不论如何，跟在运算符之后的名字都必须是对应类的成员。

* 作用域和定义在类外部的成员

​	    一个类就是一个作用域的事实能够很好的解释，为什么当我们在类的外部定义成员函数是必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。	

​	另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外，这时，返回类型必须指明它是哪个类的成员。例如，我们可能向Window_mgr类添加一个新的名为addScreen的函数，它负责向显示器添加一个新屏幕。这个成员的返回类型将是ScreenIndex，用户可以通过它定位到指定的Screen

```c++
class Window_mgr
{
public:
    //向窗口添加一个Screen，返回它的编号
    ScreenIndex addScreen(const Screen&);
	//其他成员与之前版本一致
    using ScreenIndex = std::vector<Screen>::size_type;
    //按照编号将指定的Screen重置为空白
    void clear(ScreenIndex);
private:
    std::vector<Screen> screens{Screen(24, 80, " ")};
};
//首先处理返回类型，之后我们才进入Window_mgr的作用域
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen &s)
{
    screens.push_back(s);
    return screens.size() - 1;
}
```

因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的，所以这种情况下，要想使用ScreenIndex作为返回类型，我们必须明确指定哪个类定义了它。

### 7.4.1  名字查找与类的作用域

名字查找(**name lookup**)的过程比较直截了当

* 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
* 如果没找到，继续查找外层作用域。
* 如果最终没有找到匹配的声明，则程序报错

对于定义在类内部的成员函数来说。类的定义分两步：

* 首先编译成员的声明。
* 直到类全部可见后才编译函数体。

#### (1)  用于类成员声明的名字查找

​	    这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，编译器就会在定义该类的作用域中继续查找

```c++
typedef double Money;
string bal;
class Account{
public:
	Money balance() {return bal;}
private:
    Money bal;
};
```

当编译器看到balance函数的声明时，它将在Account类的范围内寻找对Money的声明。编译器只会考虑Account中在使用Money前出现的声明，因为没有找到匹配的成员，编译器就会接着到Account的外层作用域中进行查找。上例中，编译器会找到Money的typedef语句，该类型被用作balance函数的返回类型以及数据成员bal的类型。

另一方面，balance函数体在整个类可见后才会被处理，因此该函数的return语句返回名为bal的成员，而不是外层作用域的string对象。

#### (2)  类型名要特殊处理

​	一般来说，内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。

```C++
typedef double Money;
class Account{
public:
	Money balance() { return bal; }
private:
	typedef double Money;	//错误，不能重新定义Money
    Money bal;
};
```

#### (3)  成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

* 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才会被考虑
* 如果在成员函数内没有指导，则在类内继续查找，这时类的所有成员都可以被考虑。
* 如果类内也没有找到该名字的声明，则在成员函数定义之前的作用域内继续查找

一般来说，不建议使用其他成员的名字来作为某个成员函数的参数

#### (4)  类作用域之外，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将在外围的作用域中继续查找

#### (5)  在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明

```c++
int height;
class Screen{
public:
	typedef std::string::size_type pos;
    void setHeight(pos);
    pos height = 0;	//隐藏了外层作用域中的height
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var){
    //var:参数
    //height:类的成员
    //verify:全局函数
    height = verify(var);
}
```

要注意的是，全局函数verify的声明在类定义之前是不可见的。然而，名字查找的第三步包括了成员函数出现之前的全局作用域

## 7.5  构造函数再探

### 7.5.1  构造函数初始值列表

定义变量时习惯于立即对其初始化，而不是先定义、再复制

如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。

#### (1)  构造函数的初始值有时必不可少

如果成员是const或者引用的话，必须将其初始化。类似地，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

```c++
class ConstRef{
public:
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
};
```

和其他常量对象或者引用一样，成员ci和ri都必须被初始化

(2)  成员初始化的顺序

显然，在构造函数初始值中每个成员只能出现一次，构造函数列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

成员的初始化顺序与它们在类定义的出现顺序一致：

a 第一个成员先被初始化，然后第二个，以此类推，构造函数初始值列表中初始值的前后位置不会影响实际的初始化顺序。

一般来说，初始化的顺序并没有什么特别要求。如果一个成员是用来另一个成员来初始化的，那么这两个成员的初始化顺序就很关键。

```c++
class X{
    int i;
    int j;
public:
    //未定义的：i在j之前被初始化
    X(int val):j(val),i(j){}
};
```

这个例子中，从构造函数初始值的形式上来看仿佛是先用val初始化了j，然后用j初始化i。实际上，i先被初始化，因此这个初始值的效果是识图用未定义的值j初始化i。

(2)  默认实参和构造函数

Sales_data默认构造函数的行为与只接受一个string实参的构造函数差不多。唯一区别是接受string实参的构造函数使用这个实参初始化bookNo，而默认构造函数使用string的默认构造函数初始化bookNo。将其进行重写

```c++
class Sales_data{
public:
    //
    Sales_data(std::string s = " "):bookNo(s){ }
    //
    Sales_data(std::string s,unsigned cnt, double rev):
    	bookNo(s), units_sold(cnt), revenue(rev*cnt) {}
    Sales_data(std::istream &is) { read(is, *this); }
};
```

!! 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 7.5.2  委托构造函数

C++11新标准扩展了构造函数初始值的功能，使得使得我们可以定义所谓的委托构造函数。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者说全部）职责委托给了其他构造函数。

和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。举例说明：

```c++
class Sales_data{
    public:
    	//非委托构造函数使用对应的实参初始化成员
    	Sales_data(std::string s, unsigned cnt, double price):
    		bookNo(s), units_sold(cnt), revenue(cnt*price) {}
    	//其余构造函数全部委托给另一个构造函数
    	Sales_data():Sales_data(" ", 0, 0) {}
    	Sales_data(std::string s): Sales_data(s, 0, 0) {}
    	Sales_data(std::istream &is):Sales_data() { read(is, *this); }
    	//其它成员与之前一致
};
```

在上例代码中，除了第一个构造函数外其他的都委托了它们的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。定义默认构造函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务。接受一个string的构造同样委托给了三参数的版本。

接受istream&的构造函数也是委托构造函数，它委托给了默认构造函数，默认构造函数右接着委托给了三参数构造函数。当这些受委托的构造函数执行玩后，接着执行istream&构造函数体的内容。它的构造函数体调用read函数读取给定的istream。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在Sales_data类中，受委托的构造函数体恰好是空的。假如函数体中包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。			

### 7.5.3  默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况发生：

- 当我们在块作用域内不使用任何初始值定义一个非静态变量
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时
- 当类类型成员没有在构造函数初始值列表中显式地初始化时。

值初始化在以下情况下发生：

- 在数组初始化过程中如果我们提供的初始值数量少于数组的大小时。
- 当我们不使用初始值定义一个局部静态变量时。
- 当我们通过书写形如 T( ) 的表达式显式地请求初始化是

### 7.5.4  隐式的类类型转换

如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换规则，将这种构造函数称之为转换构造函数

在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则，也就是说在需要使用Sales_data的地方，我们可以使用string或istream作为替代。

```c++
string null_book = "9-999-99999-9";
//构造一个临时的Sales_data对象
//该对象的units_sold和revenue等于0，bookNo等于null_book
item.combine(null_book);
```

 使用一个string 实参调用了Sales_data对象。新生成的这个(临时)Sales_data对象被传递给combine。因为combine的参数是一个常量引用，所以可以给该参数传递一个临时量。

#### (1)   只允许一步步类型转换

编译器会自动地执行一步类型转换

```c++
//错误：需要用户定义的两种转换
//(1) 把"9-999-99999-9"转换成Sales_data
//(2) 再把这个(临时的)string转换成Sales_data
item.combine("9-999-99999-9");
```

​	下面是正确调用，显式地把字符串转换成string或者Sales_data对象

```c++
//正确：显式地转换成string，隐式地转换成Sales_data
item.combine(string("9-999-99999-9"));
//正确：隐式地转换成string，显式地转换成Sales_data
item.combine(Sales_data("9-999-99999-9"));
```

#### (2)  类类型转换不是总有效

null_book中的string可能表示了一个不存在的ISBN编号。另一个是从istream到Sales_data的转换

```c++
//使用istream构造函数创建一个函数传递给combine
item.combine(cin);
```

代码隐式地把cin转换成Sales_data,这个转换执行了接受一个istream的Sales_data的构造函数。该构造函数通过读取标准输入创建了一个(临时的)Sales_data对象，随后将得到的对象传递给combine。

Sales_data对象其实是个临时量，一旦combine完成我们就不能再访问它了。实际上，我们构建了一会对象，先将它的值加到item中，随后将其丢弃。

#### (3)  抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，可以通过将构造函数声明为 **explicit** 加以阻止

```c++
class Sales_data{
public:
    Sales_data() = default;
    Sales_data(const std::string &s， unsigned n, double p):
    	bookNo(s), units_sold(n), revenue(p*n);
    explicit Sales_data(const std::string &s):bookNo(s) {}
    explicit Sales_data(std::istream&);
};
```

这样没有任何构造函数能用于隐式地创建Sales_data对象

关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit，（指定了也没啥用）。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。

```c++
//错误：explicit关键字只允许出现在类内的构造函数声明
explicit Sales_data::Sales_data(istream& is)
{
    read(is,*this);
}
```

#### (4)  explicit构造函数只能用于直接初始化

发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（=）。我们只能使用直接初始化而不能使用explicit构造函数

```C++
Sales_data item1(null_book);	//正确：直接初始化
Sales_data item2 = null_book;	//错误：不能将explicit构造函数用于拷贝形式的初始化过程
```

！！用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且编译器将不会在自动转换过程中使用该构造函数。

#### (5) 为转换显式地使用构造函数

尽管编译器不会讲explicit的构造函数用于隐式转换过程，但是可以使用如下构造函数来进行显式地强制转换

```c++
//正确：实参是一个显式构造的Sales_data对象
item.combine(Sales_data(null_book));
//正确：static_cast可以使用explicit的构造函数
item.combine(static_cast<Sales_data>(cin));
```

第一个调用中，直接使用Sales_data的构造函数，该调用通过接受string的构造函数创建了一个临时的Sales_data对象。在第二个调用中，使用static_cast执行了显式的转换。其中，static_cast通过istream构造函数创建了一个临时的Sales_data对象。

#### (6)  标准库中含有显式构造函数的类

- 接受一个单参数的const char*的string构造函数不是explicit的
- 接受一个容量参数的vector构造函数时explicit的

### 7.5.5  聚合类

聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时是聚合的

- 所有成员都是public的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有virtual函数

```c++
struct Data{
    int ival;
    string s;
};
```

可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：

```c++
//vall.ival = 0； vall.s = string("Anna")
Data vall = { 0, "Anna" };
```

初始值的顺序必须与声明的顺序一致。

显示地初始化类的对象的成员存在三个明显的确定：

- 需要类的所有成员都是public的。
- 将正确初始化每个对象的每个成员的重任交给了类的用户(非类的作者)。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值。
- 添加或删除一个成员后，所有的初始化语句都需要更新。

### 7.5.6  字面值常量类

回顾constexpr函数：

constexpr函数是指能用于常量表达式（指值不会改变并且在编译过程就能得到计算结果的表达式）的函数

constexpr函数的参数和返回值必须是字面值类型。除了算数类型、引用和指针外，某些类也是字面值类型。与其他类不同，字面值类型可能含有constexpr函数成员。这样的成员必须符合constexpr函数的所有要求，它们是隐式 const 的。

**数据成员都是字面值类型的聚合类是字面值常量类。**如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：

- 数据成员都必须是字面值类型
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式：或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象

#### (1)  constexpr构造函数

构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数，可以声明成 =default 的形式

## 7.6  类的静态成员

有时类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持联系

- 声明静态成员：
  - 成员的声明之前加上关键字 static 使得其与类关联在一起
  - 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据有关的数据
  - 静态成员函数不与任何对象绑定在一起，它们不包含this指针
  - 作为结果，静态成员函数不能声明成const的，而且也不能在static函数体内使用this指针
- 使用类的静态成员
  - 使用作用域运算符直接访问静态成员
  - 虽然静态成员不属于类的某个对象，但仍然可以使用类的对象、引用或者指针来访问静态成员
  - 成员函数不用通过作用域运算符就能直接使用静态成员

```c++
Account ac1;
Account *ac2 = & ac1;
r = ac1.rate();
r = ac2->rate();
```

- 定义静态成员

  - 既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，static只能出现在类内部的声明语句

    ```c++
    void Account::rate(double newRate)
    {
        interestRate = newRate;
    }
    ```

  - 因为静态数据成员不属于类的任何一个对象，所以它们不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。一般来说，不能在类的内部初始化静态成员。相反，必须在类的外部定义和初始化每个静态成员。一个静态数据成员只能定义一次

  - 类似于全局变量，静态数据成员定义在任何函数之外。因此一旦被定义，就将一直存在于程序的整个生命周期中。

  - 定义静态数据成员的方式与类的外部定义成员函数差不多。需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字

  - ```c++
    //定义并初始化一个静态成员
    double Account::interestRate = initRate();
    ```

    上述代码定义了名为interestRate的对象，该对象是类Account的静态成员，类型是double。从类名开始，这条定义语句的剩余部分就位于类的作用域之内了。因此可以直接使用initRate函数	

- 静态成员的类内初始化

  - 通常情况下，类的静态成员不能在类的内部初始化。然而，可以为静态成员提供const整数类型的类内初始值，但这要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为成员本身就是常量表达式。

    ```C++
    class Account{
    public::
        static double rate() { return interestRate; }
        static void rate(double);
    private::
        static constexpr int period = 30;		//period是常量表达式
        double daily_tbl[period];
    };
    ```

  - 如果某个静态成员的应用场景仅限于编译器可以替代它的情况，则一个初始化的const或constexpr static不需要分别定义。

  - 例如，period的唯一用途就是定义daily_tbl的维度，不需要在Account外面专门定义period。

  - 如果在类内的内部提供了一个初始值，则成员的定义不能再指定一个初始值了

  - ```c++
    constexpr int Account::period;		//初始值在类的定义内提供
    //一个不带初始值的静态成员的定义
    ```

- 静态成员能用于某些场景，而普通成员不能

  - 静态数据成员的类型可以就是它所属的类类型，而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。
  - 可以使用静态成员作为默认实参

  

